---
title: .net手动调用GC的场景
date: 2013/10/13 20:26:34
tags:
---


.net的GC机制有两个问题：首先GC并不能释放所有资源，它更不能释放非托管资源。其次，GC也不是实时的，所有GC存在不确定性。

为了解决这个问题donet提供了析构函数

![](https://common.cnblogs.com/images/copycode.gif)

public class TestClass : System.IDisposable

{

//供程序员显式调用的Dispose方法

public void Dispose()

{

//调用带参数的Dispose方法，释放托管和非托管资源

Dispose(true);

//手动调用了Dispose释放资源，那么析构函数就是不必要的了，这里阻止GC调用析构函数

System.GC.SuppressFinalize(this);

}

  


//protected的Dispose方法，保证不会被外部调用。

//传入bool值disposing以确定是否释放托管资源

protected void Dispose(bool disposing)

{

if (disposing)

{

///TODO:在这里加入清理"托管资源"的代码，应该是xxx.Dispose(); }

///TODO:在这里加入清理"非托管资源"的代码 }

  


//供GC调用的析构函数

~TestClass()

{

Dispose(false);//释放非托管资源 }

}

![](https://common.cnblogs.com/images/copycode.gif)

而即使我们忘记了在合适的时候调用Dispose，GC也会在释放对象的时候帮我们清理非托管资源的。GC所充当的角色只是一种保障手段，它应该充当这种角色，我们不能过分依赖它。实际上，在较大的模块退出时我们还应该及时地手动调用GC.Collect进行垃圾回收。

为什么实现IDisposable接口的类的对象，因为.net CLR是采用GC（垃圾回收器）机制管理内存，不想C++语言那样，能保证对象的析构函数在作用域结束时被总是被自动调用，有时如果程序运行的过程中一直没有满足启动GC的条件，则可能GC一次也没启动。 这样，如果一个类需要占用重要资源，就应该实现IDisposable接口，或者使用另一种简捷的方式：使用Using，如：

Using(MyClass myObj = new MyClass())

{ ... }

对于没有实现IDisposable接口的，也就没什么Dispose方法，但他们的Finalize同样不能保证被调用。

Using(MyClass myObj = new MyClass())

{ ... }

是一种好方法，但是只有MyClass实现了IDisposable接口才能这样写.
