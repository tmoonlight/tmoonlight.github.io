---
title: .net线程池内幕-newbier-博客园
date: 2014/8/7 14:42:12
tags:
---


[](https://www.cnblogs.com/newbier/p/6192882.html)

#  [newbier](https://www.cnblogs.com/newbier/)

随笔 - 2, 文章 - 0, 评论 - 7, 引用 - 0

##  [.net线程池内幕](https://www.cnblogs.com/newbier/p/6192882.html)

本文通过对.NET4.5的ThreadPool源码的分析讲解揭示.NET线程池的内幕，并总结ThreadPool设计的好与不足。

**线程池的作用**  
线程池，顾名思义，线程对象池。Task和TPL都有用到线程池，所以了解线程池的内幕有助于你写出更好的程序。由于篇幅有限，在这里我只讲解以下核心概念：

  * 线程池的大小
  * 如何调用线程池添加任务
  * 线程池如何执行任务



Threadpool也支持操控IOCP的线程，但在这里我们不研究它，涉及到task和TPL的会在其各自的博客中做详解。  
  
 **线程池的大小**  
不管什么池，总有尺寸，ThreadPool也不例外。ThreadPool提供了4个方法来调整线程池的大小：

  * SetMaxThreads
  * GetMaxThreads
  * SetMinThreads
  * GetMinThreads



SetMaxThreads指定线程池最多可以有多少个线程，而GetMaxThreads自然就是获取这个值。SetMinThreads指定线程池中最少存活的线程的数量，而GetMinThreads就是获取这个值。  
为何要设置一个最大数量和有一个最小数量呢？原来线程池的大小取决于若干因素，如虚拟地址空间的大小等。比如你的计算机是4g内存，而一个线程的初始堆栈大小为1m，那么你最多能创建4g/1m的线程（忽略操作系统本身以及其他进程内存分配）；正因为线程有内存开销，所以如果线程池的线程过多而又没有被完全使用，那么这就是对内存的一种浪费，所以限制线程池的最大数是很make sense的。  
那么最小数又是为啥？线程池就是线程的对象池，对象池的最大的用处是重用对象。为啥要重用线程，因为线程的创建与销毁都要占用大量的cpu时间。所以在高并发状态下，线程池由于无需创建销毁线程节约了大量时间，提高了系统的响应能力和吞吐量。最小数可以让你调整最小的存活线程数量来应对不同的高并发场景。  
  
 **如何调用线程池添加任务**  
线程池主要提供了2个方法来调用：QueueUserWorkItem和UnsafeQueueUserWorkItem。  
两个方法的代码基本一致，除了attribute不同，QueueUserWorkItem可以被partial trust的代码调用，而UnsafeQueueUserWorkItem只能被full trust的代码调用。
    
    
    1 public static bool QueueUserWorkItem(WaitCallback callBack)
    2 {
    3 StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
    4 return ThreadPool.QueueUserWorkItemHelper(callBack, (object) null, ref stackMark, true);
    5 }

QueueUserWorkItemHelper首先调用ThreadPool.EnsureVMInitialized()来确保CLR虚拟机初始化（VM是一个统称，不是单指java虚拟机，也可以指CLR的execution engine），紧接着实例化ThreadPoolWorkQueue，最后调用ThreadPoolWorkQueue的Enqueue方法并传入callback和true。
    
    
     1 [SecurityCritical]
     2 public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal)
     3 {
     4 ThreadPoolWorkQueueThreadLocals queueThreadLocals = (ThreadPoolWorkQueueThreadLocals) null;
     5 if (!forceGlobal)
     6 queueThreadLocals = ThreadPoolWorkQueueThreadLocals.threadLocals;
     7 if (this.loggingEnabled)
     8 FrameworkEventSource.Log.ThreadPoolEnqueueWorkObject((object) callback);
     9 if (queueThreadLocals != null)
    10 {
    11 queueThreadLocals.workStealingQueue.LocalPush(callback);
    12 }
    13 else
    14 {
    15 ThreadPoolWorkQueue.QueueSegment comparand = this.queueHead;
    16 while (!comparand.TryEnqueue(callback))
    17 {
    18 Interlocked.CompareExchange<ThreadPoolWorkQueue.QueueSegment>(ref comparand.Next, new ThreadPoolWorkQueue.QueueSegment(), (ThreadPoolWorkQueue.QueueSegment) null);
    19 for (; comparand.Next != null; comparand = this.queueHead)
    20 Interlocked.CompareExchange<ThreadPoolWorkQueue.QueueSegment>(ref this.queueHead, comparand.Next, comparand);
    21 }
    22 }
    23 this.EnsureThreadRequested();
    24 }

ThreadPoolWorkQueue主要包含2个“queue”(实际是数组)，一个为QueueSegment（global work queue），另一个是WorkStealingQueue(local work queue)。两者具体的区别会在Task/TPL里讲解，这里暂不解释。  
由于forceGlobal是true，所以执行到了comparand.TryEnqueue(callback)，也就是QueueSegment.TryEnqueue。comparand先从队列的头(queueHead)开始enqueue，如果不行就继续往下enqueue，成功后再赋值给queueHead。  
让我们来看看QueueSegment的源代码：
    
    
     1 public QueueSegment()
     2 {
     3 this.nodes = new IThreadPoolWorkItem[256];
     4 }
     5 
     6 public bool TryEnqueue(IThreadPoolWorkItem node)
     7 {
     8 int upper;
     9 int lower;
    10 this.GetIndexes(out upper, out lower);
    11 while (upper != this.nodes.Length)
    12 {
    13 if (this.CompareExchangeIndexes(ref upper, upper + 1, ref lower, lower))
    14 {
    15 Volatile.Write<IThreadPoolWorkItem>(ref this.nodes[upper], node);
    16 return true;
    17 }
    18 }
    19 return false;
    20 }

这个所谓的global work queue实际上是一个IThreadPoolWorkItem的数组，而且限死256，这是为啥？难道是因为和IIS线程池(也只有256个线程）对齐？使用interlock和内存写屏障volatile.write来保证nodes的正确性，比起同步锁性能有很大的提高。最后调用EnsureThreadRequested，EnsureThreadRequested会调用QCall把请求发送至CLR，由CLR调度ThreadPool。  
  
**线程池如何执行任务**  
线程被调度后通过ThreadPoolWorkQueue的Dispatch方法来执行callback。
    
    
     1 internal static bool Dispatch()
     2 {
     3 ThreadPoolWorkQueue threadPoolWorkQueue = ThreadPoolGlobals.workQueue;
     4 int tickCount = Environment.TickCount;
     5 threadPoolWorkQueue.MarkThreadRequestSatisfied();
     6 threadPoolWorkQueue.loggingEnabled = FrameworkEventSource.Log.IsEnabled(EventLevel.Verbose, (EventKeywords) 18);
     7 bool flag1 = true;
     8 IThreadPoolWorkItem callback = (IThreadPoolWorkItem) null;
     9 try
    10 {
    11 ThreadPoolWorkQueueThreadLocals tl = threadPoolWorkQueue.EnsureCurrentThreadHasQueue();
    12 while ((long) (Environment.TickCount - tickCount) < (long) ThreadPoolGlobals.tpQuantum)
    13 {
    14 try
    15 {
    16 }
    17 finally
    18 {
    19 bool missedSteal = false;
    20 threadPoolWorkQueue.Dequeue(tl, out callback, out missedSteal);
    21 if (callback == null)
    22 flag1 = missedSteal;
    23 else
    24 threadPoolWorkQueue.EnsureThreadRequested();
    25 }
    26 if (callback == null)
    27 return true;
    28 if (threadPoolWorkQueue.loggingEnabled)
    29 FrameworkEventSource.Log.ThreadPoolDequeueWorkObject((object) callback);
    30 if (ThreadPoolGlobals.enableWorkerTracking)
    31 {
    32 bool flag2 = false;
    33 try
    34 {
    35 try
    36 {
    37 }
    38 finally
    39 {
    40 ThreadPool.ReportThreadStatus(true);
    41 flag2 = true;
    42 }
    43 callback.ExecuteWorkItem();
    44 callback = (IThreadPoolWorkItem) null;
    45 }
    46 finally
    47 {
    48 if (flag2)
    49 ThreadPool.ReportThreadStatus(false);
    50 }
    51 }
    52 else
    53 {
    54 callback.ExecuteWorkItem();
    55 callback = (IThreadPoolWorkItem) null;
    56 }
    57 if (!ThreadPool.NotifyWorkItemComplete())
    58 return false;
    59 }
    60 return true;
    61 }
    62 catch (ThreadAbortException ex)
    63 {
    64 if (callback != null)
    65 callback.MarkAborted(ex);
    66 flag1 = false;
    67 }
    68 finally
    69 {
    70 if (flag1)
    71 threadPoolWorkQueue.EnsureThreadRequested();
    72 }
    73 return true;
    74 }

while语句判断如果执行时间少于30ms会不断继续执行下一个callback。这是因为大多数机器线程切换大概在30ms，如果该线程只执行了不到30ms就在等待中断线程切换那就太浪费CPU了，浪费可耻啊！  
Dequeue负责找到需要执行的callback：
    
    
     1 public void Dequeue(ThreadPoolWorkQueueThreadLocals tl, out IThreadPoolWorkItem callback, out bool missedSteal)
     2 {
     3 callback = (IThreadPoolWorkItem) null;
     4 missedSteal = false;
     5 ThreadPoolWorkQueue.WorkStealingQueue workStealingQueue1 = tl.workStealingQueue;
     6 workStealingQueue1.LocalPop(out callback);
     7 if (callback == null)
     8 {
     9 for (ThreadPoolWorkQueue.QueueSegment comparand = this.queueTail; !comparand.TryDequeue(out callback) && comparand.Next != null && comparand.IsUsedUp(); comparand = this.queueTail)
    10 Interlocked.CompareExchange<ThreadPoolWorkQueue.QueueSegment>(ref this.queueTail, comparand.Next, comparand);
    11 }
    12 if (callback != null)
    13 return;
    14 ThreadPoolWorkQueue.WorkStealingQueue[] current = ThreadPoolWorkQueue.allThreadQueues.Current;
    15 int num = tl.random.Next(current.Length);
    16 for (int length = current.Length; length > 0; --length)
    17 {
    18 ThreadPoolWorkQueue.WorkStealingQueue workStealingQueue2 = Volatile.Read<ThreadPoolWorkQueue.WorkStealingQueue>(ref current[num % current.Length]);
    19 if (workStealingQueue2 != null && workStealingQueue2 != workStealingQueue1 && workStealingQueue2.TrySteal(out callback, ref missedSteal))
    20 break;
    21 ++num;
    22 }
    23 }

因为我们把callback添加到了global work queue，所以local work queue(workStealingQueue.LocalPop(out callback))找不到callback，local work queue查找callback会在task里讲解。接着又去global work queue查找，先从global work queue的起始位置查找直至尾部，因此global work quque里的callback是FIFO的执行顺序。
    
    
     1 public bool TryDequeue(out IThreadPoolWorkItem node)
     2 {
     3 int upper;
     4 int lower;
     5 this.GetIndexes(out upper, out lower);
     6 while (lower != upper)
     7 {
     8 // ISSUE: explicit reference operation
     9 // ISSUE: variable of a reference type
    10 int& prevUpper = @upper;
    11 // ISSUE: explicit reference operation
    12 int newUpper = ^prevUpper;
    13 // ISSUE: explicit reference operation
    14 // ISSUE: variable of a reference type
    15 int& prevLower = @lower;
    16 // ISSUE: explicit reference operation
    17 int newLower = ^prevLower + 1;
    18 if (this.CompareExchangeIndexes(prevUpper, newUpper, prevLower, newLower))
    19 {
    20 SpinWait spinWait = new SpinWait();
    21 while ((node = Volatile.Read<IThreadPoolWorkItem>(ref this.nodes[lower])) == null)
    22 spinWait.SpinOnce();
    23 this.nodes[lower] = (IThreadPoolWorkItem) null;
    24 return true;
    25 }
    26 }
    27 node = (IThreadPoolWorkItem) null;
    28 return false;
    29 }

使用自旋锁和内存读屏障来避免内核态和用户态的切换，提高了获取callback的性能。如果还是没有callback，那么就从所有的local work queue里随机选取一个，然后在该local work queue里“偷取”一个任务(callback)。  
拿到callback后执行callback.ExecuteWorkItem()，通知完成。  
  
**总结**  
ThreadPool提供了方法调整线程池最少活跃的线程来应对不同的并发场景。ThreadPool带有2个work queue，一个golbal一个local。执行时先从local找任务，接着去global，最后才会去随机选取一个local偷一个任务，其中global是FIFO的执行顺序。Work queue实际上是数组，使用了大量的自旋锁和内存屏障来提高性能。但是在偷取任务上，是否可以考虑得更多，随机选择一个local太随意。首先要考虑偷取的队列上必须有可执行任务；其次可以选取一个不在调度中的线程的local work queue，这样降低了自旋锁的可能性，加快了偷取的速度；最后，偷取的时候可以考虑像golang一样偷取别人queue里一半的任务，因为执行完偷到的这一个任务之后，下次该线程再次被调度到还是可能没任务可执行，还得去偷取别人的任务，这样既浪费CPU时间，又让任务在线程上分布不均匀，降低了系统吞吐量！

另外，如果禁用log和ETW trace，可以使ThreadPool的性能更进一步。

标签 [.net](https://www.cnblogs.com/newbier/tag/.net/) , [线程池](https://www.cnblogs.com/newbier/tag/%E7%BA%BF%E7%A8%8B%E6%B1%A0/)

好文要顶 关注我 收藏该文

[newbier](https://home.cnblogs.com/u/newbier/)  
[关注 - 0](https://home.cnblogs.com/u/newbier/followees/)  
[粉丝 - 3](https://home.cnblogs.com/u/newbier/followers/)

+加关注

2

0

  
[» ](https://www.cnblogs.com/newbier/p/6203422.html) 下一篇： [.NET Task揭秘（一）](https://www.cnblogs.com/newbier/p/6203422.html "发布于 2016-12-20 17:18")

posted on 2016-12-17 18:40 [newbier](https://www.cnblogs.com/newbier/) 阅读(4682) 评论(5) [ 编辑](https://i.cnblogs.com/EditPosts.aspx?postid=6192882) 收藏

[](https://www.cnblogs.com/newbier/p/6192882.html)

[](https://www.cnblogs.com/newbier/p/6192882.html)

### 评论

##  [#1楼](https://www.cnblogs.com/newbier/p/6192882.html#3584340) [](https://www.cnblogs.com/newbier/p/6192882.html)    

LZ写的“比如你的计算机是4g内存，而一个线程的初始堆栈大小为1m，那么你最多能创建4g/1m的线程”，这个不是很严谨，首先这个是用户模式栈，然后用户模式栈windows默认1Mb，不是初始，这个值用户可设置，然后线程需要的内存还包括线程内核对象X64是1KB，内核模式栈X64是24K，线程环境块4KB........... 

支持(0)  反对(0) 

2016-12-19 12:25 | [lulianqi15](https://www.cnblogs.com/lulianqi/)

##  [#2楼](https://www.cnblogs.com/newbier/p/6192882.html#3584369) [](https://www.cnblogs.com/newbier/p/6192882.html) [楼主]    

[@](https://www.cnblogs.com/newbier/p/6192882.html#3584340 "查看所回复的评论") lulianqi15  
@lulianqi15  


[引用](https://www.cnblogs.com/newbier/p/6192882.html#3584340 "查看引用原文")

LZ写的“比如你的计算机是4g内存，而一个线程的初始堆栈大小为1m，那么你最多能创建4g/1m的线程”，这个不是很严谨，首先这个是用户模式栈，然后用户模式栈windows默认1Mb，不是初始，这个值用户可设置，然后线程需要的内存还包括线程内核对象X64是1KB，内核模式栈X64是24K，线程环境块4KB...........

  
嗯，你说的很全，这里只是打个比方，的确不严谨。初次写博客，文章段落层次排的不好，文字功底也不好，还请见谅。:) 

支持(0)  反对(0) 

2016-12-19 13:14 | [newbier](https://www.cnblogs.com/newbier/)

##  [#3楼](https://www.cnblogs.com/newbier/p/6192882.html#3588889) [](https://www.cnblogs.com/newbier/p/6192882.html)    

之前看源码时看到GC和Emit使用了QCall，原来线程池调度也使用了QCall～感谢楼主的优质文章，学习了 

支持(0)  反对(0) 

2016-12-25 08:04 | [Lemon丶](https://www.cnblogs.com/liuhaoyang/)

##  [#4楼](https://www.cnblogs.com/newbier/p/6192882.html#3589262) [](https://www.cnblogs.com/newbier/p/6192882.html)    

大神膜拜 

支持(0)  反对(0) 

2016-12-26 08:35 | [苦逼师哥](https://www.cnblogs.com/kubishishu/)

##  [#5楼](https://www.cnblogs.com/newbier/p/6192882.html#3781483) [](https://www.cnblogs.com/newbier/p/6192882.html)    

直接看不懂 

支持(0)  反对(0) 

2017-09-11 22:24 | [创新突破游子恒心](https://www.cnblogs.com/jzhao/)

[](https://www.cnblogs.com/newbier/p/6192882.html)

刷新评论[刷新页面](https://www.cnblogs.com/newbier/p/6192882.html#)[返回顶部](https://www.cnblogs.com/newbier/p/6192882.html#top)

注册用户登录后才能发表评论，请 登录 或 注册， [访问](https://www.cnblogs.com/) 网站首页。 

[【推荐】超50万C++/C#源码: 大型实时仿真组态图形源码](http://www.ucancode.com/index.htm)  
[【推荐】ALIYUN90%，大陆-港澳专线直连，创业者上云首选](https://www.aliyun90.com/)  
[【推荐】程序员问答平台，解决您开发中遇到的技术难题](https://q.cnblogs.com/)  


**相关博文：**  
· [.net线程池](https://www.cnblogs.com/vveiliang/p/6218250.html ".net线程池")  
· [线程池python](https://www.cnblogs.com/tracylining/p/3471594.html "线程池python")  
· [C#并行编程（2）：.NET线程池](https://www.cnblogs.com/chenbaoshun/p/10566124.html "C#并行编程（2）：.NET线程池")  
· [线程池专题](https://www.cnblogs.com/blacksmallcat/p/10179931.html "线程池专题")  
· [线程池 数据库连接池 内存池](https://www.cnblogs.com/zengkefu/p/7069316.html "线程池 数据库连接池 内存池")  


**最新 IT 新闻** :   
· [不秀恩爱，也没狗粮，古代七夕根本就不是情人节！](https://news.cnblogs.com/n/629343/)   
· [科学家首次远距传输三维量子比特](https://news.cnblogs.com/n/629342/)   
· [数据科学哪家强？Python和R的对决](https://news.cnblogs.com/n/629341/)   
· [人工智能公司DeepMind去年亏损5.72亿美元](https://news.cnblogs.com/n/629340/)   
· [菲律宾继续拒绝接种登革热疫苗](https://news.cnblogs.com/n/629339/)   
» [更多新闻...](https://news.cnblogs.com/ "IT 新闻")

### 导航

  * [ 博客园](https://www.cnblogs.com/)
  * [ 首页](https://www.cnblogs.com/newbier/)
  * [ 新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)
  * [ 联系](https://msg.cnblogs.com/send/newbier)
  * [ 订阅](https://www.cnblogs.com/newbier/rss/) [ ](https://www.cnblogs.com/newbier/rss/)



|  < | 2019年8月 |  >  
---|---|---  
日 | 一 | 二 | 三 | 四 | 五 | 六  
28 | 29 | 30 | 31 |  1  |  2  |  3   
4  |  5  |  6  |  7  |  8  |  9  |  10   
11  |  12  |  13  |  14  |  15  |  16  |  17   
18  |  19  |  20  |  21  |  22  |  23  |  24   
25  |  26  |  27  |  28  |  29  |  30  |  31   
1  |  2  |  3  |  4  |  5  |  6  |  7   
  
### 公告

昵称： [ newbier ](https://home.cnblogs.com/u/newbier/)   
园龄： [ 2年7个月 ](https://home.cnblogs.com/u/newbier/ "入园时间：2016-12-14")   
粉丝： [ 3 ](https://home.cnblogs.com/u/newbier/followers/)   
关注： [ 0 ](https://home.cnblogs.com/u/newbier/followees/)

+加关注

### 搜索

  

  

###  常用链接 

  * [我的随笔](https://www.cnblogs.com/newbier/p/ "我的博客的随笔列表")
  * [我的评论](https://www.cnblogs.com/newbier/MyComments.html "我的发表过的评论列表")
  * [我的参与](https://www.cnblogs.com/newbier/OtherPosts.html "我评论过的随笔列表")
  * [最新评论](https://www.cnblogs.com/newbier/RecentComments.html "我的博客的评论列表")
  * [我的标签](https://www.cnblogs.com/newbier/tag/ "我的博客的标签列表")



### 我的标签

  * [.net](https://www.cnblogs.com/newbier/tag/.net/)(2) 
  * [task](https://www.cnblogs.com/newbier/tag/task/)(1) 
  * [线程池](https://www.cnblogs.com/newbier/tag/%E7%BA%BF%E7%A8%8B%E6%B1%A0/)(1) 



###  随笔档案 

  * [ 2016年12月(2) ](https://www.cnblogs.com/newbier/archive/2016/12.html)



### 最新评论

  * [1\. Re:.NET Task揭秘（一）](http://www.cnblogs.com/newbier/p/6203422.html#4007857)
  * 大兄弟~~啥时候更新二呢~~
  * \--_York
  * [2\. Re:.net线程池内幕](http://www.cnblogs.com/newbier/p/6192882.html#3781483)
  * 直接看不懂
  * \--创新突破游子恒心
  * [3\. Re:.NET Task揭秘（一）](http://www.cnblogs.com/newbier/p/6203422.html#3658364)
  * 大兄弟~~啥时候更新二呢~~
  * \--Ziev
  * [4\. Re:.net线程池内幕](http://www.cnblogs.com/newbier/p/6192882.html#3589262)
  * 大神膜拜
  * \--苦逼师哥
  * [5\. Re:.net线程池内幕](http://www.cnblogs.com/newbier/p/6192882.html#3588889)
  * 之前看源码时看到GC和Emit使用了QCall，原来线程池调度也使用了QCall～感谢楼主的优质文章，学习了
  * \--时光之后



### 阅读排行榜

  * [ 1\. .NET Task揭秘（一）(5012) ](https://www.cnblogs.com/newbier/p/6203422.html)
  * [ 2\. .net线程池内幕(4682) ](https://www.cnblogs.com/newbier/p/6192882.html)



### 评论排行榜

  * [ 1\. .net线程池内幕(5) ](https://www.cnblogs.com/newbier/p/6192882.html)
  * [ 2\. .NET Task揭秘（一）(2) ](https://www.cnblogs.com/newbier/p/6203422.html)



### 推荐排行榜

  * [ 1\. .net线程池内幕(2) ](https://www.cnblogs.com/newbier/p/6192882.html)
  * [ 2\. .NET Task揭秘（一）(1) ](https://www.cnblogs.com/newbier/p/6203422.html)



Powered by:   
[博客园](https://www.cnblogs.com/)   
Copyright © 2019 newbier 
