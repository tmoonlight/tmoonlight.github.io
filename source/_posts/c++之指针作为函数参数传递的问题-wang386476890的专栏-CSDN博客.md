---
title: c++之指针作为函数参数传递的问题-wang386476890的专栏-CSDN博客
date: 2014/8/2 20:35:11
tags:
---


### 热门频道

  * [首页

](https://www.csdn.net/ "CSDN首页")
  * [博客

](https://blog.csdn.net/ "博客")
  * [学院

](https://edu.csdn.net/ "学院")
  * [VIP

](https://mall.csdn.net/vip "VIP")
  * [APP

](https://www.csdn.net/apps/download?code=wap_1555569676 "App")
  * [问答

](https://ask.csdn.net/ "问答")
  * [下载

](https://download.csdn.net/ "下载")



### 推荐频道

  * [商城

](https://h5.youzan.com/v2/showcase/homepage?alias=BUj3rrGa2J&ps=760 "商城")
  * [论坛

](https://bbs.csdn.net/ "论坛")
  * [活动

](http://huiyi.csdn.net/ "活动")
  * [招聘

](http://job.csdn.net/ "招聘")
  * [GitChat

](https://gitbook.cn/?ref=csdn "GitChat")
  * [ITeye

](http://www.iteye.com/ "ITeye")
  * [专题

](https://spec.csdn.net/ "专题")



[打开CSDN APP](https://www.csdn.net/apps/download?code=wap_1555569676)

Copyright © 1999-2019, CSDN.NET, All Rights Reserved

[](http://so.csdn.net/so/?t=blog)

[登录](https://passport.csdn.net/account/login?ref=toolbar)

[](https://my.csdn.net/)

#  转 c++之指针作为函数参数传递的问题 

[ wang386476890 ](https://blog.csdn.net/wang386476890) 阅读数：3277 2018-09-30

转自：<http://blog.csdn.net/fjb2080/article/details/5623427>

 

原创文章，转载请注明出处，谢谢！  
作者：清林，博客名：飞空静渡

 

博客地址：<http://blog.csdn.net/fjb2080>

 

其实，对于C 或者C++ ，最难的一块地方估计就是指针了。指针是强大的，但也是很多人载在这里的地方。

 

前段时间写了一篇文章《[C](http://blog.csdn.net/fjb2080/archive/2010/05/14/5591580.aspx) [＋＋之 数组与指针的异同](http://blog.csdn.net/fjb2080/archive/2010/05/14/5591580.aspx) 》对C 和C ＋＋中的指针做了一个初步的讲解。这次将讲解一下指针作为函数参数传递的问题。

 

很多人对于指针的使用是有所了解的，但还是经常会载在指针的问题上，是因为还不够了解指针的本质，其实如果了解指针的本质，对指针的使用也就一目了然了。

 

作为C 的初学者，经常会遇到指针作为函数参数传递的两个经典的问题。这里，我将透过指针的本质来来讲解这两个问题，这样以后无论你遇到什么样的指针问题，如果你以这样的方法来分析指针也许就迎刃而解了！

 

首先，第一个问题是这样的：

写一个函数，交换两个参数中的值。

 

初学者往往会这样写：

 

void exchange(int x, int y)

{

int p=x;

x = y;

y = p;

}

 

之后，你会查找资料了解到应该这样写：

void exchange(int ＊x, int ＊y)

{

int ＊p=x;

＊x = ＊y;

＊y = ＊p;

}

 

第二个问题是，写一个给某个指针分配内存的函数：

初学者往往是这样写：

void my_malloc(void* p, int size)

{

p = malloc(sizeof(int)*size);

}

 

然后又查在资料，知道应该这么写：

void my_malloc(void** p, int size)

{

*p = malloc(sizeof(int)*size);

}

 

虽然，网上很多这样的讨论，也有很多人做过很多的解释，但始终都无法给出一个令人一目了然，并可以长久记住的说法，这篇文章就是想试图解决这样的问题，给初学者一个原理性的了解！

 

首先，一定一定记住一点，  **指针和变量一样，也是有地址的，只不过变量的值被解释成一个值，而指针的值被解释成一个地址。**

 

下面，我们看一下代码：

void main()

{

int x;

int *p;

}

 

我们看这个函数的内存结构：

 

这是一个函数的栈结构，我们可以看到，变量和指针都占用了4 个字节。而且，由于我们对它们没有初始化，所以变量x 和指针p 里的内容都是随机的，就是说x 的值是不确定的，p 有可能指向某个内存地址，如果现在对p 操作也许会导致程序崩溃。

 

其实，我们记住了，指针也是有地址的 这个概念，很多问题就迎刃而解了。

 

下面，我来分析一下，指针作为函数参数传递的情况。

如果，我们的代码是这样的，你看会怎么样：

 

int main(int argc, char* argv[])

{

int *a = new int(10);

func(a);

 

return 0;

}

 

第一个要说的当然是：指针也是有地址的。

第二个要说的是：当给一个函数的参数传递一个变量是，这个变量是复制过去的。

 

对于第二点，我们在理解void exchange(int x, int y) 函数想交换这两个变量的的值时就应该理解了。

例如：

int a;

int b;

exchange(a,b);

不能交换a 和b 的值，因为此时exchange(a,b) 中的a 和b 并不是原来的a 和b 变量，它们只不过是被复制过去了。

 

有了这两个概念，就不难理解指针作为函数参数传递的问题。

 

首先，我们来看下上面的代码中的a 指针和p 指针的内存结构。

我们看到，当我们以a 作为func 函数的参数传递进去的时候，函数复制了这个指针，但这两个指针的内容是一样的，也就是说是指向同一个内存，即10 。

 

如果你还不了解的话，我就通过一段代码和测试再来说明：

 

 

**[cpp]**  [view plain](http://blog.csdn.net/fjb2080/article/details/5623427#) [copy](http://blog.csdn.net/fjb2080/article/details/5623427#)

 [print](http://blog.csdn.net/fjb2080/article/details/5623427#)[?](http://blog.csdn.net/fjb2080/article/details/5623427#)

  1. #include <stdio.h>  
  2. void func(int* p)  
  3. {  
  4.     printf("*p = %d/n", *p);  
  5.     printf("&p = %p/n", &p);  
  6. }  
  7. int main(int argc, char *argv[])  
  8. {  
  9.     int *a = new int(10);  
  10.     printf("*a = %d/n", *a);  
  11.     printf("&a = %p/n", &a);  
  12.     func(a);  
  13.     return 0;  
  14. }  



 

 

 

编译：g++ -g -Wall test1.cpp

运行：./a.out

输出：

*a = 10

&a = 0xbfd4447c

*p = 10

&p = 0xbfd44460

 

我们看到输出，a 指向的地址的值和p 指向的地址里的值是一样的，都是10 。然而，对于指针a 和p 来说，它们自身的地址是不一样的，所以我们看到，函数func 复制了指针a 给p ，它们的值一样，但有不同的地址，是不同的指针。

 

我们再进一步：

 

**[cpp]**  [view plain](http://blog.csdn.net/fjb2080/article/details/5623427#) [copy](http://blog.csdn.net/fjb2080/article/details/5623427#)

 [print](http://blog.csdn.net/fjb2080/article/details/5623427#)[?](http://blog.csdn.net/fjb2080/article/details/5623427#)

  1. #include <stdio.h>  
  2. void func(int* p)  
  3. {  
  4.     printf("*p = %d/n", *p);  
  5.     printf("&p = %p/n", &p);  
  6.     printf("&*p = %p/n", &*p);  
  7. }  
  8. int main(int argc, char *argv[])  
  9. {  
  10.     int *a = new int(10);  
  11.     printf("*a = %d/n", *a);  
  12.     printf("&a = %p/n", &a);  
  13.     printf("&*a = %p/n", &*a);  
  14.     func(a);  
  15.     return 0;  
  16. }  



 

 

 

编译输出：

*a = 10

&a = 0xbfe1c77c

&*a = 0x94b6008

*p = 10

&p = 0xbfe1c760

&*p = 0x94b6008

 

我们可以进一步看到，a 指针所指向的值的地址和p 指针所指向的值的地址是一样的，都是 0x94b6008 ，就如同上图所示，为了加深印象，再看一下这个图 ，然后再对比一下程序输出 ，然后在体会一下我在上面提到的两点 ，一点是：指针是有地址的 。另一点是：函数的参数是复制过去的 。

 

 

 

说到这里，我们再回到文章开始时提到的两个问题，一个是交换问题：

 

void exchange(int ＊x, int ＊y)

{

int ＊p=x;

＊x = ＊y;

＊y = ＊p;

}

 

那么这样为什么可以交换：

int a = 2;

int b = 3;

exchange(&a, &b);

 

上我们以a 和b 的地址传递给exchange 函数时，函数复制了这两个地址，并赋值给x 和y 这个两个指针，这两个指针是指向变量a 和b 的，它们的图形如下：

 

那么，当我们反引用指针时：

int ＊p=x;

＊x = ＊y;

＊y = ＊p;

 

我们操作的是a 和b 里面的变量的值，所以，我们交换a 和b 的值就成功了。

 

我们再来看下第二个问题：

void my_malloc(void* p, int size)

{

p = malloc(sizeof(int)*size);

}

当这样时：

int *a;

my_malloc(a, 10);

为什么这个会失败！

 

下面，我来分析一下：

当我们调用my_malloc(a, 10); 函数，而函数还没执行到p = malloc(size); 语句时，情况是这样的：

 

我们看到a 和p 的指针的值都是一样的，都是指向某个不确定的地址。

这时，我们执行这个语句：

p = malloc(sizeof(int)*size);

我们把这个语句分开两部分来看，一个是先执行malloc(sizeof(int)*size) ，然后在执行赋值语句，把malloc(sizeof(int)*size) 的返回值付给p 。

第一步：先执行malloc(sizeof(int)*size) ；（这里我们只考虑malloc 分配内存成功的情况）

 

第二步：把执行malloc(sizeof(int)*size) 的返回值付给了p ，如下图：

 

由上图，我们可以知道，这就是为什么，我们还是不能给a 分配地址的了。

 

下面我们来分析这个：

void my_malloc(void** p, int size)

{

*p = malloc(sizeof(int)*size);

}

 

int *a;

my_malloc(&a ， 10);

这样执行，为什么会成功！

 

 

我们看到，当执行函数

my_malloc(void** p, int size);

但还没有执行

*p = malloc(sizeof(int)*size);

语句时，它们的内存结构图如下所示：

 

其实这里，我们可以把二维指针和一维指针当成和变量一样，也是有地址的。只不过它的解释不一样而已。

变量：里面的值是一个数值。

一维指针：里面的值是个地址，而这个地址里的值是个数值。

二维指针：里面的值是个地址，而这个地址里的值也是个地址。

 

那么，我看着图来解释p ：

p 里面是一个地址，这个地址是&a ，即是a 指针的地址值，而a 指针地址里面的值也是个地址，这个地址是指向一个不确定的地方，说得坳口，慢慢对比图来理解就会好了！

 

执行malloc(size) 后的图如下：

 

然后在执行赋值语句：

*p = malloc(sizeof(int)*size);

后，如下图所示：

 

然后，我们就给指针a 分配内存成功了。

 

本文的pdf下载地址：[c++之指针作为函数参数传递的问题.pdf](http://download.csdn.net/source/2392586)

[打开APP，阅读全文](https://blog.csdn.net/wang386476890/article/details/82907259)

当前没有评论 [ 点击发表评论](https://blog.csdn.net/wang386476890/comment/post?id=82907259)

[

#### _指针_ _作为_ _函数_ _参数传递_ 的 _问题_

Cheatscat 948次阅读 08-23 APP打开 ](https://blog.csdn.net/Cheatscat/article/details/77508878 "指针作为函数参数传递的问题")

[

#### 数组和 _指针_ _作为_ _函数_ 参数——高质量C、 _C++_ 编程指南

wxc237786026 2195次阅读 06-14 APP打开 ](https://blog.csdn.net/wxc237786026/article/details/46489329 "数组和指针作为函数参数——高质量C、C++编程指南")

[

#### _指针_ _作为_ _函数_ _参数传递_ 时需要注意的 _问题_ \- ascend的专栏 - CSDN博客

2019-6-14](https://blog.csdn.net/avrmcu1/article/details/39001641)

[

#### c/ _c++_ 使用 _指针_ 做 _函数_ 返回值和 _指针_ 作 _函数_ 参数 _问题_ \- zha..._CSDN博客

2019-6-7](https://blog.csdn.net/zhangjikuan/article/details/51848567)

[

#### _指针_ _作为_ 参数传入 _函数_ 的陷阱

Move_now 5397次阅读 05-14 APP打开 ](https://blog.csdn.net/Move_now/article/details/71944689 "指针作为参数传入函数的陷阱")

[

#### _C++_ 用指向 _函数_ 的 _指针_ _作为_ _函数_ 参数 - Lavi的专栏 - CSDN博客

2019-7-3](https://blog.csdn.net/liuweiyuxiang/article/details/84842075)

[

####  _函数_ 参数的传递 _问题_ ( _指针_ 的 _指针_ ) - 杨正的专栏 - CSDN博客

2018-11-22](https://blog.csdn.net/yangzheng_yz/article/details/52487085)

[

#### _指针_ 的学习（3） _指针_ _作为_ _函数_ 的参数的输入和输出的参数的特性

Poisx 1977次阅读 08-26 APP打开 ](https://blog.csdn.net/Poisx/article/details/77606566 "指针的学习（3）指针作为函数的参数的输入和输出的参数的特性")

[

#### _指针_ _作为_ 参数的经典例子

lyshahaha 1307次阅读 03-02 APP打开 ](https://blog.csdn.net/lyshahaha/article/details/79426985 "指针作为参数的经典例子")

[

#### _指针_ _作为_ _函数_ _参数传递_ 的 _问题_ \- Cheatscat的博客 - CSDN博客

2019-6-23](https://blog.csdn.net/Cheatscat/article/details/77508878)

[

#### C语言 _函数_ 传递 _指针_ 参数的 _问题_ \- L_Aster的专栏 - CSDN博客

2019-7-8](https://blog.csdn.net/gl486546/article/details/53375999)

[

#### _指针_ 和引用 _作为_ _函数_ 参数的区别

lannister_awalys_pay 1286次阅读 12-02 APP打开 ](https://blog.csdn.net/lannister_awalys_pay/article/details/84699574 "指针和引用作为函数参数的区别")

[

#### c语言 _指针_ _作为_ _函数_ 的参数

qq_39248122 10631次阅读 07-09 APP打开 ](https://blog.csdn.net/qq_39248122/article/details/80976942 "c语言指针作为函数的参数")

[

#### _c++_ 中 _函数_ _参数传递_ (值传递、 _指针_ 传递,引用传递)进一步..._CSDN博客

2019-4-2](https://blog.csdn.net/richerg85/article/details/14450183)

[

#### 普通值、 _指针_ 、引用 _作为_ _函数_ 参数时的理解 - 夏天的风的..._CSDN博客

2019-4-16](https://blog.csdn.net/this_is_me_anyway/article/details/80192574)

[

#### 普通值、 _指针_ 、引用 _作为_ _函数_ 参数时的理解

this_is_me_anyway 1502次阅读 05-04 APP打开 ](https://blog.csdn.net/this_is_me_anyway/article/details/80192574 "普通值、指针、引用作为函数参数时的理解")

[

#### C语言 _指针_ _作为_ _函数_ _参数传递_ 学习(一) - 行者三个石的博客 - CSDN博客

2019-7-26](https://blog.csdn.net/qq_33706673/article/details/84669784)undefined 

[

#### 浅谈C/ _C++_ 回调 _函数_ （Callback）& _函数_ _指针_

u012339743 14475次阅读 04-08 APP打开 ](https://blog.csdn.net/u012339743/article/details/69789300 "浅谈C/C++回调函数（Callback）& 函数指针")

[

#### C语言 _指针_ _作为_ _函数_ _参数传递_ 学习(一)

qq_33706673 1636次阅读 12-01 APP打开 ](https://blog.csdn.net/qq_33706673/article/details/84669784 "C语言指针作为函数参数传递学习\(一\)")

[

#### C语言学习笔记—— _指针_ 、数组 _作为_ _函数_ _参数传递_ 的方式

qq_21834027 2713次阅读 01-03 APP打开 ](https://blog.csdn.net/qq_21834027/article/details/85705266 "C语言学习笔记——指针、数组作为函数参数传递的方式")

[

#### 以 _指针_ _作为_ 引用参数(一)

Li_haiyu 407次阅读 10-30 APP打开 ](https://blog.csdn.net/Li_haiyu/article/details/83539135 "以指针作为引用参数\(一\)")

[

#### _C++_ 中namespace的用法

RainVictor1 3915次阅读 02-02 APP打开 ](https://blog.csdn.net/RainVictor1/article/details/79235936 "C++中namespace的用法")

[

#### 数组传参， _指针_ _作为_ 参数

SoYangA 2504次阅读 06-09 APP打开 ](https://blog.csdn.net/SoYangA/article/details/80633463 "数组传参，指针作为参数")

[

#### _指针_ 变量 _作为_ _函数_ 参数

Coder__CS 11699次阅读 07-04 APP打开 ](https://blog.csdn.net/Coder__CS/article/details/51823035 "指针变量作为函数参数")

[

#### _c++_ 用 _指针_ 将 _函数_ _作为_ 参数传参

qq_36615589 674次阅读 05-16 APP打开 ](https://blog.csdn.net/qq_36615589/article/details/80336708 "c++ 用指针将函数作为参数传参")

[

#### _C++_ 类成员 _函数_ 的 _函数_ _指针_

afei__ 3969次阅读 08-23 APP打开 ](https://blog.csdn.net/afei__/article/details/81985937 "C++ 类成员函数的函数指针")

[

#### C语言中 _指针_ 变量 _作为_ _函数_ 参数和一般变量 _作为_ _函数_ 参数的区别

fullbug 14033次阅读 04-09 APP打开 ](https://blog.csdn.net/fullbug/article/details/1557508 "C语言中指针变量作为函数参数和一般变量作为函数参数的区别")

[

#### C语言中“ _指针_ ” _作为_ “ _函数_ 参数”时的注意事项

dan15188387481 8939次阅读 10-23 APP打开 ](https://blog.csdn.net/dan15188387481/article/details/49363605 "C语言中“指针”作为“函数参数”时的注意事项")

[

#### _指针_ _作为_ _函数_ _参数传递_ 时需要注意的 _问题_

avrmcu1 1743次阅读 09-02 APP打开 ](https://blog.csdn.net/avrmcu1/article/details/39001641 "指针作为函数参数传递时需要注意的问题")

[

#### _函数_ _指针_ _作为_ 某个 _函数_ 的参数及定义 _函数_ _指针_ （回调 _函数_ ）

dagefeijiqumeiguo 16743次阅读 06-17 APP打开 ](https://blog.csdn.net/dagefeijiqumeiguo/article/details/73393369 "函数指针作为某个函数的参数及定义函数指针（回调函数）")

[

#### _C++_ 中一级 _指针_ 和双重（二级） _指针_ _作为_ _函数_ _参数传递_

u014694994 2624次阅读 06-07 APP打开 ](https://blog.csdn.net/u014694994/article/details/80611268 "C++中一级指针和双重（二级）指针作为函数参数传递")

[

#### 如何正确使用 _指针_ ( _指针_ _作为_ 输出型参数)与结构体 _指针_ _作为_ _函数_ 参数

TongxinV 5123次阅读 02-10 APP打开 ](https://blog.csdn.net/TongxinV/article/details/54970733 "如何正确使用指针\(指针作为输出型参数\)与结构体指针作为函数参数")

[

#### 【 _C++_ 】用 _指针_ 做 _函数_ 参数

CSDN___CSDN 163次阅读 10-05 APP打开 ](https://blog.csdn.net/CSDN___CSDN/article/details/82944252 "【C++】用指针做函数参数")

[

#### _C++_ _指针_ 的引用做 _函数_ 参数

error0_dameng 852次阅读 08-19 APP打开 ](https://blog.csdn.net/error0_dameng/article/details/81836285 "C++    指针的引用做函数参数")

[

#### _C++_ 中 _函数_ 参数类型为 _指针_ 的 _指针_

hou09tian 1745次阅读 08-08 APP打开 ](https://blog.csdn.net/hou09tian/article/details/81501621 "C++中函数参数类型为指针的指针")

[

#### _C++_ 中参数何时用引用或是 _指针_

xuzheng11332 1909次阅读 04-21 APP打开 ](https://blog.csdn.net/xuzheng11332/article/details/70318228 "C++中参数何时用引用或是指针")

[

#### _c++_ 成员 _函数_ _指针_ 的本质

tangchuxian080 1654次阅读 06-16 APP打开 ](https://blog.csdn.net/tangchuxian080/article/details/80711339 "c++成员函数指针的本质")

[

#### C/ _C++_ 回调方式系列之一 _函数_ _指针_ 和 _函数_ 回调模式

SweetTool 2698次阅读 05-20 APP打开 ](https://blog.csdn.net/SweetTool/article/details/72578801 "C/C++回调方式系列之一  函数指针和函数回调模式")

[

#### 【转】嗯，让我们彻底搞懂C/ _C++_ _函数_ _指针_ 吧

u010525694 4520次阅读 06-07 APP打开 ](https://blog.csdn.net/u010525694/article/details/72897766 "【转】嗯，让我们彻底搞懂C/C++函数指针吧")

[

#### _C++_ 委托实现( _函数_ _指针_ ，function+bind，委托模式)

lijun538 3322次阅读 04-28 APP打开 ](https://blog.csdn.net/lijun538/article/details/51277199 "C++委托实现\(函数指针，function+bind，委托模式\)")

[

#### _C++_ 那些细节-- _函数_ _指针_

puppet_master 2737次阅读 10-31 APP打开 ](https://blog.csdn.net/puppet_master/article/details/49368863 "C++那些细节--函数指针")

[

#### _C++_ 浅析 _函数_ _指针_

zhang_alongzd 203次阅读 05-29 APP打开 ](https://blog.csdn.net/zhang_alongzd/article/details/51532928 "C++浅析函数指针")

[

#### c/ _c++_ 向 _函数_ 传递 _指针_ 并修改其指向的 _问题_

bin510729392 4811次阅读 05-22 APP打开 ](https://blog.csdn.net/bin510729392/article/details/51476327 "c/c++向函数传递指针并修改其指向的问题")

[

#### _C++_ 中 _函数_ _指针_ 的使用

sruru 63505次阅读 08-28 APP打开 ](https://blog.csdn.net/sruru/article/details/7916296 "C++中函数指针的使用")

[

#### Qt _C++_ _函数_ _指针_ _作为_ _函数_ 的参数

u012230798 366次阅读 03-07 APP打开 ](https://blog.csdn.net/u012230798/article/details/88288821 "Qt   C++ 函数指针作为函数的参数")

[

#### _函数_ _指针_ _作为_ 某个 _函数_ 的参数

dengm155 1810次阅读 01-07 APP打开 ](https://blog.csdn.net/dengm155/article/details/54176505 "函数指针作为某个函数的参数")

[

#### _函数_ _指针_ 及含参 _函数_ _指针_ 做参数的实现

xishuang_gongzi 1138次阅读 07-30 APP打开 ](https://blog.csdn.net/xishuang_gongzi/article/details/81279854 "函数指针及含参函数指针做参数的实现")

点赞 2

评论

收藏

[ 返回  
顶部 ](https://blog.csdn.net/wang386476890/article/details/82907259)

文章收藏成功
