---
title: 一像素
date: 2013/9/9 0:46:10
tags:
---


[](https://github.com/git-onepixel)

[一像素](http://www.cnblogs.com/onepixel/)

[博客园](http://www.cnblogs.com/)

[首页](http://www.cnblogs.com/onepixel/)

[新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)

[联系](https://msg.cnblogs.com/send/%E4%B8%80%E5%83%8F%E7%B4%A0)

[订阅](http://www.cnblogs.com/onepixel/rss)

[管理](https://i.cnblogs.com/)

随笔-31  文章-9  评论-303 

# [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)

### 0、算法概述

#### 

#### 0.1 算法分类

十种常见排序算法可以分为两大类：

> 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。
> 
> 线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 

![](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402132530342-980121409.png)

#### 0.2 算法复杂度

![](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

0.3 相关概念

> 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
> 
> 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
> 
> 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
> 
> 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

### 1、冒泡排序（Bubble Sort）

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

#### 1.1 算法描述

比较相邻的元素。如果第一个比第二个大，就交换它们两个；

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；

针对所有的元素重复以上的步骤，除了最后一个；

重复步骤1~3，直到排序完成。

1.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

#### 1.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

| 

function bubbleSort(arr) {

    var len = arr.length;

    for (var i = 0; i < len - 1; i++) {

        for (var j = 0; j < len - 1 - i; j++) {

            if (arr[j] > arr[j+1]) {       // 相邻元素两两对比

                var temp = arr[j+1];       // 元素交换

                arr[j+1] = arr[j];

                arr[j] = temp;

            }

        }

    }

    return arr;

}  
  
---|---  
  
  


### 2、选择排序（Selection Sort）

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

#### 2.1 算法描述

n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

初始状态：无序区为R[1..n]，有序区为空；

第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；

n-1趟结束，数组有序化了。

#### 2.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)　　

#### 2.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

| 

function selectionSort(arr) {

    var len = arr.length;

    var minIndex, temp;

    for (var i = 0; i < len - 1; i++) {

        minIndex = i;

        for (var j = i + 1; j < len; j++) {

            if (arr[j] < arr[minIndex]) {    // 寻找最小的数

                minIndex = j;                // 将最小数的索引保存

            }

        }

        temp = arr[i];

        arr[i] = arr[minIndex];

        arr[minIndex] = temp;

    }

    return arr;

}   
  
---|---  
  
  


#### 2.4 算法分析

表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

### 3、插入排序（Insertion Sort）

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

#### 3.1 算法描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

从第一个元素开始，该元素可以认为已经被排序；

取出下一个元素，在已经排序的元素序列中从后向前扫描；

如果该元素（已排序）大于新元素，将该元素移到下一位置；

重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；

将新元素插入到该位置后；

重复步骤2~5。

#### 3.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

#### 3.2 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

| 

function insertionSort(arr) {

    var len = arr.length;

    var preIndex, current;

    for (var i = 1; i < len; i++) {

        preIndex = i - 1;

        current = arr[i];

        while (preIndex >= 0 && arr[preIndex] > current) {

            arr[preIndex + 1] = arr[preIndex];

            preIndex--;

        }

        arr[preIndex + 1] = current;

    }

    return arr;

}  
  
---|---  
  
  


#### 3.4 算法分析

插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

### 4、希尔排序（Shell Sort）

1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

#### 4.1 算法描述

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；

按增量序列个数k，对序列进行k 趟排序；

每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

#### 4.2 动图演示

![](https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif)

#### 4.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

| 

function shellSort(arr) {

    var len = arr.length,

        temp,

        gap = 1;

    while (gap < len / 3) {         // 动态定义间隔序列

        gap = gap * 3 + 1;

    }

    for (gap; gap > 0; gap = Math.floor(gap / 3)) {

        for (var i = gap; i < len; i++) {

            temp = arr[i];

            for (var j = i-gap; j > 0 && arr[j]> temp; j-=gap) {

                arr[j + gap] = arr[j];

            }

            arr[j + gap] = temp;

        }

    }

    return arr;

}  
  
---|---  
  
  


#### 4.4 算法分析

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　

### 5、归并排序（Merge Sort）

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

#### 5.1 算法描述

把长度为n的输入序列分成两个长度为n/2的子序列；

对这两个子序列分别采用归并排序；

将两个排序好的子序列合并成一个最终的排序序列。

#### 5.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif)

#### 5.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

| 

function mergeSort(arr) { // 采用自上而下的递归方法

    var len = arr.length;

    if (len < 2) {

        return arr;

    }

    var middle = Math.floor(len / 2),

        left = arr.slice(0, middle),

        right = arr.slice(middle);

    return merge(mergeSort(left), mergeSort(right));

}

 

function merge(left, right) {

    var result = [];

 

    while (left.length>0 && right.length>0) {

        if (left[0] <= right[0]) {

            result.push(left.shift());

        }else {

            result.push(right.shift());

        }

    }

 

    while (left.length)

        result.push(left.shift());

 

    while (right.length)

        result.push(right.shift());

 

    return result;

}  
  
---|---  
  
  


#### 5.4 算法分析

归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

### 6、快速排序（Quick Sort）

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

#### 6.1 算法描述

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

从数列中挑出一个元素，称为 “基准”（pivot）；

重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

#### 6.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

#### 6.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

| 

function quickSort(arr, left, right) {

    var len = arr.length,

        partitionIndex,

        left =typeof left !='number' ? 0 : left,

        right =typeof right !='number' ? len - 1 : right;

 

    if (left < right) {

        partitionIndex = partition(arr, left, right);

        quickSort(arr, left, partitionIndex-1);

        quickSort(arr, partitionIndex+1, right);

    }

    return arr;

}

 

function partition(arr, left ,right) {    // 分区操作

    var pivot = left,                     // 设定基准值（pivot）

        index = pivot + 1;

    for (var i = index; i <= right; i++) {

        if (arr[i] < arr[pivot]) {

            swap(arr, i, index);

            index++;

        }       

    }

    swap(arr, pivot, index - 1);

    return index-1;

}

 

function swap(arr, i, j) {

    var temp = arr[i];

    arr[i] = arr[j];

    arr[j] = temp;

}  
  
---|---  
  
  


### 7、堆排序（Heap Sort）

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

#### 7.1 算法描述

将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；

将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；

由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

#### 7.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif)

#### 7.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

| 

var len;   // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

 

function buildMaxHeap(arr) {  // 建立大顶堆

    len = arr.length;

    for (var i = Math.floor(len/2); i >= 0; i--) {

        heapify(arr, i);

    }

}

 

function heapify(arr, i) {    // 堆调整

    var left = 2 * i + 1,

        right = 2 * i + 2,

        largest = i;

 

    if (left < len && arr[left] > arr[largest]) {

        largest = left;

    }

 

    if (right < len && arr[right] > arr[largest]) {

        largest = right;

    }

 

    if (largest != i) {

        swap(arr, i, largest);

        heapify(arr, largest);

    }

}

 

function swap(arr, i, j) {

    var temp = arr[i];

    arr[i] = arr[j];

    arr[j] = temp;

}

 

function heapSort(arr) {

    buildMaxHeap(arr);

 

    for (var i = arr.length - 1; i > 0; i--) {

        swap(arr, 0, i);

        len--;

        heapify(arr, 0);

    }

    return arr;

}  
  
---|---  
  
  


### 8、计数排序（Counting Sort）

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

#### 8.1 算法描述

找出待排序的数组中最大和最小的元素；

统计数组中每个值为i的元素出现的次数，存入数组C的第i项；

对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；

反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

#### 8.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif)

#### 8.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

| 

function countingSort(arr, maxValue) {

    var bucket =new Array(maxValue + 1),

        sortedIndex = 0;

        arrLen = arr.length,

        bucketLen = maxValue + 1;

 

    for (var i = 0; i < arrLen; i++) {

        if (!bucket[arr[i]]) {

            bucket[arr[i]] = 0;

        }

        bucket[arr[i]]++;

    }

 

    for (var j = 0; j < bucketLen; j++) {

        while(bucket[j] > 0) {

            arr[sortedIndex++] = j;

            bucket[j]--;

        }

    }

 

    return arr;

}  
  
---|---  
  
  


#### 8.4 算法分析

计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

### 9、桶排序（Bucket Sort）

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

#### 9.1 算法描述

设置一个定量的数组当作空桶；

遍历输入数据，并且把数据一个一个放到对应的桶里去；

对每个不是空的桶进行排序；

从不是空的桶里把排好序的数据拼接起来。 

#### 9.2 图片演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png)

#### 9.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

| 

function bucketSort(arr, bucketSize) {

    if (arr.length === 0) {

      return arr;

    }

 

    var i;

    var minValue = arr[0];

    var maxValue = arr[0];

    for (i = 1; i < arr.length; i++) {

      if (arr[i] < minValue) {

          minValue = arr[i];               // 输入数据的最小值

      }else if (arr[i] > maxValue) {

          maxValue = arr[i];               // 输入数据的最大值

      }

    }

 

    // 桶的初始化

    var DEFAULT_BUCKET_SIZE = 5;           // 设置桶的默认数量为5

    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;

    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  

    var buckets =new Array(bucketCount);

    for (i = 0; i < buckets.length; i++) {

        buckets[i] = [];

    }

 

    // 利用映射函数将数据分配到各个桶中

    for (i = 0; i < arr.length; i++) {

        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);

    }

 

    arr.length = 0;

    for (i = 0; i < buckets.length; i++) {

        insertionSort(buckets[i]);                     // 对每个桶进行排序，这里使用了插入排序

        for (var j = 0; j < buckets[i].length; j++) {

            arr.push(buckets[i][j]);                     

        }

    }

 

    return arr;

}  
  
---|---  
  
  


#### 9.4 算法分析

桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 

### 10、基数排序（Radix Sort）

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

#### 10.1 算法描述

取得数组中的最大数，并取得位数；

arr为原始数组，从最低位开始取每个位组成radix数组；

对radix进行计数排序（利用计数排序适用于小范围数的特点）；

#### 10.2 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif) 

#### 10.3 代码实现

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

| 

// LSD Radix Sort

var counter = [];

function radixSort(arr, maxDigit) {

    var mod = 10;

    var dev = 1;

    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {

        for(var j = 0; j < arr.length; j++) {

            var bucket = parseInt((arr[j] % mod) / dev);

            if(counter[bucket]==null) {

                counter[bucket] = [];

            }

            counter[bucket].push(arr[j]);

        }

        var pos = 0;

        for(var j = 0; j < counter.length; j++) {

            var value =null;

            if(counter[j]!=null) {

                while ((value = counter[j].shift()) !=null) {

                      arr[pos++] = value;

                }

          }

        }

    }

    return arr;

}  
  
---|---  
  
  


#### 10.4 算法分析

基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。

基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。

 

 

　　

分类: [算法](http://www.cnblogs.com/onepixel/category/1193519.html)

好文要顶 关注我 收藏该文 ![](https://common.cnblogs.com/images/icon_weibo_24.png) ![](https://common.cnblogs.com/images/wechat.png)

[![](https://pic.cnblogs.com/face/849589/20151205235751.png)](http://home.cnblogs.com/u/onepixel/)

[一像素](http://home.cnblogs.com/u/onepixel/)

[关注 - 28](http://home.cnblogs.com/u/onepixel/followees)

[粉丝 - 580](http://home.cnblogs.com/u/onepixel/followers)

+加关注

24

0

[«](http://www.cnblogs.com/onepixel/p/7468343.html)[ ](http://www.cnblogs.com/onepixel/p/7468343.html)上一篇：[小端字节序与大端字节序](http://www.cnblogs.com/onepixel/p/7468343.html "发布于2017-09-02 23:12")

[»](http://www.cnblogs.com/onepixel/p/8724526.html)[ ](http://www.cnblogs.com/onepixel/p/8724526.html)下一篇：[简单介绍 CPU 的工作原理](http://www.cnblogs.com/onepixel/p/8724526.html "发布于2018-04-05 22:12")

posted @ 2017-10-15 23:43 [一像素](http://www.cnblogs.com/onepixel/) 阅读(77960) 评论(15) [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=7674659) [收藏](https://www.cnblogs.com/onepixel/articles/7674659.html#)

评论列表

  

[#1楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3922815) 2018-03-14 16:50 [一清](http://www.cnblogs.com/xuyiqing/) [ ](http://msg.cnblogs.com/send/%E4%B8%80%E6%B8%85 "发送站内短消息")

总体做的很不错，希尔排序的代码为什么运行后不是需要的结果？

支持(0)反对(0)

  

[#2楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3928050) 2018-03-20 10:52 [_hungryBoy](http://www.cnblogs.com/cloundSunshine/) [ ](http://msg.cnblogs.com/send/_hungryBoy "发送站内短消息")

请问博主的动画效果是怎么做的？

支持(1)反对(0)

  

[#3楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3936397) 2018-03-29 09:16 [筱筱汀](http://www.cnblogs.com/zitayang/) [ ](http://msg.cnblogs.com/send/%E7%AD%B1%E7%AD%B1%E6%B1%80 "发送站内短消息")

动图显示得好清晰！感谢博主！

支持(1)反对(0)

  

[#4楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3937930) 2018-03-30 15:42 [AlvinZH](http://www.cnblogs.com/AlvinZH/) [ ](http://msg.cnblogs.com/send/AlvinZH "发送站内短消息")

希尔排序的平均时间复杂度少了一个平方吧，代码也写错了，代码可以这样写：

  


1

2

3

4

5

6

7

8

9

10

11

12

13

14

| 

void shellSort(vector<int> &nums) {

    int n = nums.size();

    int gap, i, j;

     

    for(gap = n/2; gap > 0; gap /= 2) {

        //插入排序简洁写法

        for(i = gap; i < n; i++) {

            int num = nums[i];

            for(j = i-gap; j>=0 && nums[j]>num; j-=gap)

                nums[j+gap] = nums[j];

            nums[j+gap] = num;

        }

    }

}  
  
---|---  
  
  


支持(4)反对(2)

  

[#5楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3943863) 2018-04-07 08:33 [fanjiyue](http://home.cnblogs.com/u/876891/) [ ](http://msg.cnblogs.com/send/fanjiyue "发送站内短消息")

感谢博主（为了这四个字我登陆了半天）

支持(0)反对(0)

  

[#6楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3944473)[楼主] 2018-04-07 22:48 [一像素](http://www.cnblogs.com/onepixel/) [ ](http://msg.cnblogs.com/send/%E4%B8%80%E5%83%8F%E7%B4%A0 "发送站内短消息")

[@](https://www.cnblogs.com/onepixel/articles/7674659.html#3943863 "查看所回复的评论") fanjiyue

谢谢！

支持(0)反对(0)

  

[#7楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3953963) 2018-04-17 17:23 [青山牧云人](http://www.cnblogs.com/ArsenalfanInECNU/) [ ](http://msg.cnblogs.com/send/%E9%9D%92%E5%B1%B1%E7%89%A7%E4%BA%91%E4%BA%BA "发送站内短消息")

冒泡排序的实现有点问题，按照目前的代码只能是O(n*n)的时间复杂度。

应该设置一个标志位检测是否发生数据交换，如果没有发生数据交换，直接完成排序，这样才有可能达到O(n)的时间复杂度。

支持(0)反对(0)

  

[#8楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3954636) 2018-04-18 13:52 [Oran](http://www.cnblogs.com/OranBlog/) [ ](http://msg.cnblogs.com/send/Oran "发送站内短消息")

希尔排序的实现也有问题， 4 3 6 5 这样的序列的排序结果这个算法的结果是 4 3 5 6

支持(0)反对(0)

  

[#9楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3962414) 2018-04-27 13:41 [danboard](http://home.cnblogs.com/u/1374275/) [ ](http://msg.cnblogs.com/send/danboard "发送站内短消息")

请问博主可以转载吗？

支持(0)反对(0)

  

[#10楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3967812) 2018-05-05 11:50 [LZA](http://home.cnblogs.com/u/1285468/) [ ](http://msg.cnblogs.com/send/LZA "发送站内短消息")

特地注册滚来感谢博主!

支持(0)反对(0)

  

[#11楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3979785) 2018-05-22 17:18 [三十五画生](http://www.cnblogs.com/joy-1120/) [ ](http://msg.cnblogs.com/send/%E4%B8%89%E5%8D%81%E4%BA%94%E7%94%BB%E7%94%9F "发送站内短消息")

感谢博主

支持(0)反对(0)

  

[#12楼](https://www.cnblogs.com/onepixel/articles/7674659.html#3982685) 2018-05-26 13:17 [throuthstrom](http://www.cnblogs.com/playburst/) [ ](http://msg.cnblogs.com/send/throuthstrom "发送站内短消息")

这也太厉害了吧

支持(0)反对(0)

  

[#13楼](https://www.cnblogs.com/onepixel/articles/7674659.html#4008671) 2018-06-29 13:57 [longfeiz](http://www.cnblogs.com/merryyou/) [ ](http://msg.cnblogs.com/send/longfeiz "发送站内短消息")

习惯性mark

支持(0)反对(0)

  

[#14楼](https://www.cnblogs.com/onepixel/articles/7674659.html#4015637) 2018-07-08 21:41 [坏坏62](http://home.cnblogs.com/u/1423684/) [ ](http://msg.cnblogs.com/send/%E5%9D%8F%E5%9D%8F62 "发送站内短消息")

这篇博文我要好好的学习，对排序算法一直都没有系统的学习 就知道个大概， 代码也是写不出来。感谢博主

支持(0)反对(0)

  

[#15楼](https://www.cnblogs.com/onepixel/articles/7674659.html#4017809) 2018-07-11 10:59 [Lin_G_Q](http://home.cnblogs.com/u/1436876/) [ ](http://msg.cnblogs.com/send/Lin_G_Q "发送站内短消息")

谢谢博主大佬

支持(0)反对(0)

刷新评论[刷新页面](https://www.cnblogs.com/onepixel/articles/7674659.html#)[返回顶部](https://www.cnblogs.com/onepixel/articles/7674659.html#top)

注册用户登录后才能发表评论，请 登录 或 注册，[访问](http://www.cnblogs.com/)网站首页。

最新IT新闻:

· [华大癌变](https://news.cnblogs.com/n/601660/)

· [华为秘密战略“达芬奇计划”曝光，特朗普慌不慌？](https://news.cnblogs.com/n/601659/)

· [《我不是药神》票房破20亿大关 捐款金额达800万元](https://news.cnblogs.com/n/601643/)

· [Facebook：剑桥分析未获取印尼100万用户个人数据](https://news.cnblogs.com/n/601656/)

· [南华早报：滴滴放缓融资计划 目标2019年下半年上市](https://news.cnblogs.com/n/601655/)

» [更多新闻...](http://news.cnblogs.com/ "IT新闻")

最新知识库文章:

· [危害程序员职业生涯的三大观念](http://kb.cnblogs.com/page/598963/)

· [断点单步跟踪是一种低效的调试方法](http://kb.cnblogs.com/page/601061/)

· [测试 | 让每一粒尘埃有的放矢](http://kb.cnblogs.com/page/600804/)

· [从Excel到微服务](http://kb.cnblogs.com/page/599854/)

· [如何提升你的能力？给年轻程序员的几条建议](http://kb.cnblogs.com/page/522513/)

» [更多知识库文章...](http://kb.cnblogs.com/)

### 公告

  


您是第

| 

| 

位访客  
  
---|---|---  
  
微博：[一像素](https://weibo.com/u/2714741303 "博客园 | 一像素官方微博")[more](https://weibo.com/u/2714741303 "博客园 | 一像素官方微博")

昵称：[一像素](https://home.cnblogs.com/u/onepixel/)

园龄：[2年7个月](https://home.cnblogs.com/u/onepixel/ "入园时间：2015-12-02")

粉丝：[580](https://home.cnblogs.com/u/onepixel/followers/)

关注：[28](https://home.cnblogs.com/u/onepixel/followees/)

+加关注

### 最新随笔

[1\. Linux 开启和关闭 Ping 操作](http://www.cnblogs.com/onepixel/p/9272546.html)

[2\. CentOS 查看和修改 Mysql 字符集](http://www.cnblogs.com/onepixel/p/9154884.html)

[3\. JavaScript 内存泄露问题](http://www.cnblogs.com/onepixel/p/8832776.html)

[4\. 简单介绍 CPU 的工作原理](http://www.cnblogs.com/onepixel/p/8724526.html)

[5\. 正则表达式零宽断言详解](http://www.cnblogs.com/onepixel/articles/7717789.html)

[6\. 十大经典排序算法（动图演示）](http://www.cnblogs.com/onepixel/p/7674659.html)

[7\. 详解 setTimeout、setImmediate、process.nextTick 的区别](http://www.cnblogs.com/onepixel/articles/7605465.html)

[8\. Ajax、Comet 与 Websocket](http://www.cnblogs.com/onepixel/articles/7596023.html)

[9\. iframe跨域POST提交](http://www.cnblogs.com/onepixel/articles/7568856.html)

[10\. 详解 CORS 跨域资源共享](http://www.cnblogs.com/onepixel/articles/7568001.html)

### 随笔分类(44)

[CSS3(3)](https://www.cnblogs.com/onepixel/category/765754.html)

[ES6(2)](https://www.cnblogs.com/onepixel/category/1035472.html)

[HTML5(4)](https://www.cnblogs.com/onepixel/category/792275.html)

[jQuery(1)](https://www.cnblogs.com/onepixel/category/792316.html)

[JS(23)](https://www.cnblogs.com/onepixel/category/763999.html)

[Node(3)](https://www.cnblogs.com/onepixel/category/765775.html)

[React(1)](https://www.cnblogs.com/onepixel/category/767134.html)

[V8(1)](https://www.cnblogs.com/onepixel/category/1065677.html)

[Vue(1)](https://www.cnblogs.com/onepixel/category/905569.html)

[计算机原理(2)](https://www.cnblogs.com/onepixel/category/1193099.html)

[算法(1)](https://www.cnblogs.com/onepixel/category/1193519.html)

[网络通信(2)](https://www.cnblogs.com/onepixel/category/1023906.html)

### 文章分类(7)

[Node(1)](https://www.cnblogs.com/onepixel/category/1088440.html)

[计算机原理(1)](https://www.cnblogs.com/onepixel/category/1064679.html)

[跨域请求(4)](https://www.cnblogs.com/onepixel/category/1084011.html)

[算法](https://www.cnblogs.com/onepixel/category/1096942.html)

[网络通信(1)](https://www.cnblogs.com/onepixel/category/1087099.html)

### 文章档案(9)

[2018年4月 (1)](https://www.cnblogs.com/onepixel/archives/2018/04.html)

[2017年10月 (1)](https://www.cnblogs.com/onepixel/archives/2017/10.html)

[2017年9月 (6)](https://www.cnblogs.com/onepixel/archives/2017/09.html)

[2017年8月 (1)](https://www.cnblogs.com/onepixel/archives/2017/08.html)

### 微博

### 积分与排名

积分 - 77076

排名 - 4919

### 最新评论

[1\. Re:十大经典排序算法（动图演示）](http://www.cnblogs.com/onepixel/p/7674659.html#4017809)

谢谢博主大佬

\--Lin_G_Q

[2\. Re:十大经典排序算法（动图演示）](http://www.cnblogs.com/onepixel/p/7674659.html#4015637)

这篇博文我要好好的学习，对排序算法一直都没有系统的学习 就知道个大概， 代码也是写不出来。感谢博主

\--坏坏62

[3\. Re:让你分分钟理解 JavaScript 闭包](http://www.cnblogs.com/onepixel/p/5062456.html#4014048)

js不是标记计数回收吗??

\--you1you

[4\. Re:十大经典排序算法（动图演示）](http://www.cnblogs.com/onepixel/p/7674659.html#4008671)

习惯性mark

\--longfeiz

[5\. Re:Web前端知识体系精简](http://www.cnblogs.com/onepixel/p/7021506.html#4004753)

666,帮新手少走了太多弯路，一直觉得前端不比任何后端语言简单

\--jiefangqudetian

### 阅读排行榜

[1\. 十大经典排序算法（动图演示）(77954)](https://www.cnblogs.com/onepixel/p/7674659.html)

[2\. Vue.js 和 MVVM 小细节(30868)](https://www.cnblogs.com/onepixel/p/6034307.html)

[3\. 使用 Node.js 搭建 Web 服务器(28715)](https://www.cnblogs.com/onepixel/p/5327594.html)

[4\. 让你分分钟理解 JavaScript 闭包(24556)](https://www.cnblogs.com/onepixel/p/5062456.html)

[5\. 判断JS数据类型的四种方法(20558)](https://www.cnblogs.com/onepixel/p/5126046.html)

[6\. 正则表达式基础知识(18651)](https://www.cnblogs.com/onepixel/p/5218904.html)

[7\. 认识原型对象和原型链(18227)](https://www.cnblogs.com/onepixel/p/5024903.html)

[8\. 深入理解 new 操作符(16988)](https://www.cnblogs.com/onepixel/p/5043523.html)

[9\. H5单页面手势滑屏切换原理(16119)](https://www.cnblogs.com/onepixel/p/5300445.html)

[10\. Web前端知识体系精简(14391)](https://www.cnblogs.com/onepixel/p/7021506.html)

[11\. 深入浅出 TCP/IP 协议栈(12682)](https://www.cnblogs.com/onepixel/p/7092302.html)

[12\. JavaScript中的 NaN 与 isNaN(11782)](https://www.cnblogs.com/onepixel/p/5281796.html)

[13\. React 基础入门(11228)](https://www.cnblogs.com/onepixel/p/5248200.html)

[14\. 探索JS引擎工作原理(7444)](https://www.cnblogs.com/onepixel/p/5090799.html)

[15\. 快速构建H5单页面切换应用(5748)](https://www.cnblogs.com/onepixel/p/5156442.html)

[16\. Node.js 事件循环机制(5185)](https://www.cnblogs.com/onepixel/p/7143769.html)

[17\. 函数作用域和作用域链(4988)](https://www.cnblogs.com/onepixel/p/5036369.html)

[18\. 深入理解 call，apply 和 bind(4147)](https://www.cnblogs.com/onepixel/p/5143863.html)

[19\. 细说 JavaScript 七种数据类型(3653)](https://www.cnblogs.com/onepixel/p/5140944.html)

[20\. 浅析 jQuery 内部架构设计(3564)](https://www.cnblogs.com/onepixel/p/5097584.html)

[21\. 数组常用操作方法总结(2832)](https://www.cnblogs.com/onepixel/p/5123115.html)

[22\. 对 Undefined 与 Null 的一些理解(1208)](https://www.cnblogs.com/onepixel/p/7337248.html)

[23\. requestAnimationFrame 知多少？(1167)](https://www.cnblogs.com/onepixel/p/7078617.html)

[24\. 简单介绍 CPU 的工作原理(1061)](https://www.cnblogs.com/onepixel/p/8724526.html)

[25\. JavaScript 中的四舍五入(859)](https://www.cnblogs.com/onepixel/p/5141566.html)

[26\. V8引擎的垃圾回收策略(750)](https://www.cnblogs.com/onepixel/p/7422820.html)

[27\. JavaScript 内存泄露问题(277)](https://www.cnblogs.com/onepixel/p/8832776.html)

[28\. 小端字节序与大端字节序(200)](https://www.cnblogs.com/onepixel/p/7468343.html)

[29\. TTL 和 DNS TTL 的区别(98)](https://www.cnblogs.com/onepixel/p/7159529.html)

[30\. CentOS 查看和修改 Mysql 字符集(35)](https://www.cnblogs.com/onepixel/p/9154884.html)

[31\. Linux 开启和关闭 Ping 操作(21)](https://www.cnblogs.com/onepixel/p/9272546.html)

### 评论排行榜

[1\. 让你分分钟理解 JavaScript 闭包(80)](https://www.cnblogs.com/onepixel/p/5062456.html)

[2\. Vue.js 和 MVVM 小细节(41)](https://www.cnblogs.com/onepixel/p/6034307.html)

[3\. Web前端知识体系精简(18)](https://www.cnblogs.com/onepixel/p/7021506.html)

[4\. 深入理解 new 操作符(17)](https://www.cnblogs.com/onepixel/p/5043523.html)

[5\. Node.js 事件循环机制(15)](https://www.cnblogs.com/onepixel/p/7143769.html)

[6\. 十大经典排序算法（动图演示）(15)](https://www.cnblogs.com/onepixel/p/7674659.html)

[7\. 使用 Node.js 搭建 Web 服务器(14)](https://www.cnblogs.com/onepixel/p/5327594.html)

[8\. H5单页面手势滑屏切换原理(14)](https://www.cnblogs.com/onepixel/p/5300445.html)

[9\. 认识原型对象和原型链(13)](https://www.cnblogs.com/onepixel/p/5024903.html)

[10\. 探索JS引擎工作原理(12)](https://www.cnblogs.com/onepixel/p/5090799.html)

[11\. 函数作用域和作用域链(11)](https://www.cnblogs.com/onepixel/p/5036369.html)

[12\. 深入理解 call，apply 和 bind(8)](https://www.cnblogs.com/onepixel/p/5143863.html)

[13\. 深入浅出 TCP/IP 协议栈(7)](https://www.cnblogs.com/onepixel/p/7092302.html)

[14\. 浅析 jQuery 内部架构设计(7)](https://www.cnblogs.com/onepixel/p/5097584.html)

[15\. React 基础入门(7)](https://www.cnblogs.com/onepixel/p/5248200.html)

[16\. 对 Undefined 与 Null 的一些理解(6)](https://www.cnblogs.com/onepixel/p/7337248.html)

[17\. 快速构建H5单页面切换应用(5)](https://www.cnblogs.com/onepixel/p/5156442.html)

[18\. 数组常用操作方法总结(4)](https://www.cnblogs.com/onepixel/p/5123115.html)

[19\. V8引擎的垃圾回收策略(2)](https://www.cnblogs.com/onepixel/p/7422820.html)

[20\. 正则表达式基础知识(2)](https://www.cnblogs.com/onepixel/p/5218904.html)

### 推荐排行榜

[1\. 让你分分钟理解 JavaScript 闭包(185)](https://www.cnblogs.com/onepixel/p/5062456.html)

[2\. Web前端知识体系精简(70)](https://www.cnblogs.com/onepixel/p/7021506.html)

[3\. Vue.js 和 MVVM 小细节(50)](https://www.cnblogs.com/onepixel/p/6034307.html)

[4\. 十大经典排序算法（动图演示）(24)](https://www.cnblogs.com/onepixel/p/7674659.html)

[5\. 深入浅出 TCP/IP 协议栈(23)](https://www.cnblogs.com/onepixel/p/7092302.html)

[6\. 探索JS引擎工作原理(16)](https://www.cnblogs.com/onepixel/p/5090799.html)

[7\. 深入理解 call，apply 和 bind(15)](https://www.cnblogs.com/onepixel/p/5143863.html)

[8\. 认识原型对象和原型链(15)](https://www.cnblogs.com/onepixel/p/5024903.html)

[9\. 正则表达式基础知识(13)](https://www.cnblogs.com/onepixel/p/5218904.html)

[10\. H5单页面手势滑屏切换原理(11)](https://www.cnblogs.com/onepixel/p/5300445.html)

[11\. 函数作用域和作用域链(11)](https://www.cnblogs.com/onepixel/p/5036369.html)

[12\. 深入理解 new 操作符(10)](https://www.cnblogs.com/onepixel/p/5043523.html)

[13\. React 基础入门(10)](https://www.cnblogs.com/onepixel/p/5248200.html)

[14\. Node.js 事件循环机制(9)](https://www.cnblogs.com/onepixel/p/7143769.html)

[15\. JavaScript中的 NaN 与 isNaN(7)](https://www.cnblogs.com/onepixel/p/5281796.html)

[16\. requestAnimationFrame 知多少？(6)](https://www.cnblogs.com/onepixel/p/7078617.html)

[17\. 判断JS数据类型的四种方法(6)](https://www.cnblogs.com/onepixel/p/5126046.html)

[18\. 数组常用操作方法总结(5)](https://www.cnblogs.com/onepixel/p/5123115.html)

[19\. 使用 Node.js 搭建 Web 服务器(5)](https://www.cnblogs.com/onepixel/p/5327594.html)

[20\. 细说 JavaScript 七种数据类型(5)](https://www.cnblogs.com/onepixel/p/5140944.html)

[21\. 快速构建H5单页面切换应用(4)](https://www.cnblogs.com/onepixel/p/5156442.html)

[22\. 浅析 jQuery 内部架构设计(3)](https://www.cnblogs.com/onepixel/p/5097584.html)

[23\. JavaScript 中的四舍五入(1)](https://www.cnblogs.com/onepixel/p/5141566.html)

[24\. 简单介绍 CPU 的工作原理(1)](https://www.cnblogs.com/onepixel/p/8724526.html)

[25\. V8引擎的垃圾回收策略(1)](https://www.cnblogs.com/onepixel/p/7422820.html)

Copyright ©2018 一像素

  

